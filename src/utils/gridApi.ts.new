import { GridApiResponse, GridMatch } from '../types/grid';

// Helper function to fetch matches from GRID API
export async function fetchUpcomingMatches(): Promise<GridMatch[]> {
  const currentDate = new Date();
  const nextMonth = new Date();
  nextMonth.setMonth(currentDate.getMonth() + 1);

  // Note: Removed 'query' name to simplify the GraphQL query
  const query = `
    {
      allSeries(
        filter: {
          startTimeScheduled: {
            gte: "${currentDate.toISOString()}"
            lte: "${nextMonth.toISOString()}"
          }
        }
        orderBy: StartTimeScheduled
        first: 100
      ) {
        edges {
          node {
            id
            title {
              nameShortened
            }
            tournament {
              nameShortened
            }
            startTimeScheduled
            format {
              name
              nameShortened
            }
            teams {
              baseInfo {
                name
                nameShortened
              }
              scoreAdvantage
            }
          }
        }
      }
    }
  `;

  try {
    const response = await fetch('https://api-op.grid.gg/central-data/graphql', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ 
        query 
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('API response not ok:', errorText);
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const responseData = await response.json();
    console.log('API Response:', responseData);

    // Early return if the response structure is invalid
    if (!responseData?.data?.allSeries?.edges) {
      console.error('Invalid API response structure:', responseData);
      if (responseData.errors) {
        console.error('GraphQL Errors:', responseData.errors);
      }
      return [];
    }

    type SeriesEdge = GridApiResponse['data']['allSeries']['edges'][number];
    const edges = responseData.data.allSeries.edges as SeriesEdge[];
    
    // Process and return the matches
    return edges
      .filter((edge: SeriesEdge) => 
        edge.node.title.nameShortened.toLowerCase() === 'cs2'
      )
      .map((edge: SeriesEdge) => ({
        id: edge.node.id,
        tournament: edge.node.tournament.nameShortened,
        team1: edge.node.teams[0]?.baseInfo.name || 'TBD',
        team2: edge.node.teams[1]?.baseInfo.name || 'TBD',
        time: new Date(edge.node.startTimeScheduled).toLocaleTimeString([], { 
          hour: '2-digit', 
          minute: '2-digit' 
        }),
        date: new Date(edge.node.startTimeScheduled).toLocaleDateString(),
        game: 'CS2',
        format: edge.node.format.nameShortened
      }));
  } catch (error) {
    console.error('Error fetching matches:', error);
    return [];
  }
}